---
status: working
date: 2026-02-12
context: Phase 2 High Priority Fixes - Implementation Plan
---

# Phase 2: High Priority Fixes - Implementation Plan

## Summary

**Status**: Planning complete, ready to implement
**Estimated Duration**: 1h 45min
**Priority**: High (Production UX improvements)
**Blockers**: None (Phase 1 complete ‚úÖ)

---

## Goals

Make Grove command execution production-ready with:
1. **No data loss** - Ring buffer keeps last 10K lines (not arbitrary truncation at 1MB)
2. **User control** - Stop long-running commands gracefully
3. **Spec compliance** - Error messages match Grove specification format

---

## Task Breakdown

### Task 2.1: Output Ring Buffer (30 min)

**Problem**: Current 1MB byte-based truncation loses end of output (where errors usually are)

**Current Behavior**:
```rust
// grove/src/tui.rs - CURRENT (BAD)
const MAX_OUTPUT_BYTES: usize = 1_048_576; // 1MB
if self.output_bytes > MAX_OUTPUT_BYTES {
    self.output_truncated = true; // Stops accepting output!
    return;
}
```

**Issues**:
- Stops accepting output after 1MB (may miss exit code messages)
- No indication WHERE truncation happened
- Arbitrary byte limit doesn't align with line boundaries

**Solution**: Ring buffer keeping last 10,000 lines

**Implementation Steps**:
1. Change from byte tracking to line tracking
2. When buffer exceeds 10K lines, drop oldest 1K lines
3. Add truncation marker at start
4. Show warning in status bar
5. Adjust scroll position to stay in bounds
6. Keep accepting new output (don't stop!)

**Files to Modify**:
- `grove/src/tui.rs`:
  - Update `App` struct: remove `output_bytes`, add `output_truncated_start`
  - Update `handle_command_events()` - implement ring buffer logic
  - Update `render_command_output()` - show truncation marker

**Testing Approach**:
```bash
# Create test command that outputs 15,000 lines
commands:
  spam:
    run: seq 1 15000
    description: Test ring buffer with large output
```

**Verification**:
- [ ] Shows "earlier output truncated" marker at top
- [ ] Shows lines 5000-15000 (last 10K)
- [ ] Exit code message visible at end
- [ ] Scroll position correct
- [ ] Status bar shows warning

**Acceptance Criteria**:
- No data loss at end of output
- Clear indication of truncation
- Exit code always visible
- Smooth scrolling through visible lines

**Estimated Effort**: 30 minutes

---

### Task 2.2: Command Cancellation (1 hour)

**Problem**: No way to stop long-running or stuck commands

**Current Behavior**:
- Can only close output pane with 'q'
- Command keeps running in background
- No process cleanup

**Solution**: SIGTERM support with confirmation dialog

**Implementation Steps**:
1. Add `nix` crate dependency for Unix signals
2. Capture process PID when spawning command
3. Add `CommandEvent::Started(pid)` variant
4. Add confirmation dialog when pressing 'q' on running command
5. Send SIGTERM on confirmation
6. Gracefully handle Windows (show "not supported" message)

**Files to Modify**:
- `grove/Cargo.toml`:
  - Add `nix = { version = "0.27", features = ["signal"] }` for Unix only
- `grove/src/tui.rs`:
  - Update `CommandEvent` enum - add `Started(u32)`
  - Update `App` struct - add `running_command_pid`, `show_stop_confirmation`
  - Update `spawn_command()` - send PID after spawn
  - Update `handle_command_events()` - capture PID
  - Update `handle_key()` - show confirmation on 'q' if running
  - Add `render_stop_confirmation()` - modal dialog
  - Update `render()` - draw dialog when active

**Testing Approach**:
```bash
# Test with long-running command
commands:
  slow:
    run: sleep 30
    description: Long-running command for testing cancellation

  infinite:
    run: while true; do echo "tick"; sleep 1; done
    description: Infinite loop for testing SIGTERM
```

**Manual Test Cases**:
1. Run `slow`, press 'q' during execution
   - Should show: "Stop running command? (y/n)"
2. Press 'y' ‚Üí Command stops, pane closes
3. Press 'n' ‚Üí Dialog closes, command continues
4. Press Esc ‚Üí Dialog closes, command continues
5. Run `slow`, wait for completion, press 'q'
   - Should close immediately (no confirmation)
6. Verify process killed: `ps aux | grep sleep` should be empty

**Platform Considerations**:
- **Unix**: Full SIGTERM support ‚úì
- **Windows**: Show "not supported" message (graceful degradation)
- **macOS**: Same as Linux (SIGTERM works)

**Acceptance Criteria**:
- [ ] Confirmation dialog appears when stopping running command
- [ ] SIGTERM sent and process killed on confirmation
- [ ] Dialog cancellable with 'n' or Esc
- [ ] No confirmation when command already finished
- [ ] Graceful Windows message
- [ ] No zombie processes left behind

**Estimated Effort**: 1 hour

---

### Task 2.3: Error Message Format (15 min)

**Problem**: Error messages don't match Grove specification

**Spec Requirements**:
```
Success: "‚úì Command completed successfully"
Failure: "‚úó Command failed with exit code N"
```

**Current Behavior**:
- Only shows status bar message
- No completion message in output pane
- No Unicode symbols

**Solution**: Add spec-compliant completion messages to output

**Implementation Steps**:
1. Check Unicode support with `supports_unicode()`
2. Add completion message to output lines (not just status bar)
3. Use ‚úì/‚úó symbols (or ASCII fallbacks)
4. Auto-scroll to bottom to show completion message
5. Match exact spec format

**Files to Modify**:
- `grove/src/tui.rs`:
  - Update `handle_command_events()` - add completion message to output
  - Add Unicode detection (already exists?)
  - Auto-scroll to bottom on completion

**Testing Approach**:
```bash
# Test success
commands:
  success:
    run: echo "all good"
# Expected output: "‚úì Command completed successfully"

# Test failure
commands:
  fail:
    run: exit 42
# Expected output: "‚úó Command failed with exit code 42"

# Test ASCII fallback (if no Unicode)
export LANG=C
# Expected: "* Command completed successfully" (or "X" for failure)
```

**Verification**:
- [ ] Success shows "‚úì Command completed successfully"
- [ ] Failure shows "‚úó Command failed with exit code N"
- [ ] ASCII fallback works ("*" and "X")
- [ ] Message appears in output pane (scrolled to bottom)
- [ ] Status bar also updated

**Acceptance Criteria**:
- Exact spec compliance
- Unicode symbols on supporting terminals
- ASCII fallback for non-Unicode
- Always visible (auto-scroll)

**Estimated Effort**: 15 minutes

---

## Implementation Order

### Step 1: Task 2.3 (15 min) - Error Message Format ‚úÖ EASY WIN
**Rationale**: Simplest task, no dependencies, immediate visual improvement

1. Update `handle_command_events()` completion handling
2. Add Unicode detection
3. Add completion messages to output
4. Test with success and failure commands

**Expected Duration**: 15 minutes
**Risk**: Low
**Impact**: Medium (spec compliance, better UX)

---

### Step 2: Task 2.1 (30 min) - Output Ring Buffer ‚ö†Ô∏è MODERATE
**Rationale**: Medium complexity, no external dependencies

1. Update App struct (remove `output_bytes`, add tracking)
2. Implement ring buffer logic in `handle_command_events()`
3. Add truncation marker and warning
4. Test with large output command

**Expected Duration**: 30 minutes
**Risk**: Medium (scroll position adjustment tricky)
**Impact**: High (prevents data loss)

---

### Step 3: Task 2.2 (1 hour) - Command Cancellation ‚ö†Ô∏è COMPLEX
**Rationale**: Most complex, needs new dependency, platform-specific code

1. Add `nix` dependency to Cargo.toml
2. Update `CommandEvent` enum
3. Capture and track PID
4. Implement confirmation dialog UI
5. Add SIGTERM logic (Unix only)
6. Test thoroughly

**Expected Duration**: 1 hour
**Risk**: High (signals, process management, platform-specific)
**Impact**: High (essential UX feature)

---

## Risk Assessment

### Low Risk
- ‚úÖ Task 2.3 (Error format) - Simple string formatting

### Medium Risk
- ‚ö†Ô∏è Task 2.1 (Ring buffer) - Scroll position math could be tricky

### High Risk
- üî¥ Task 2.2 (Cancellation) - Process signals, platform differences

### Mitigation Strategies

**For Task 2.1 (Ring buffer)**:
- Test scroll position edge cases:
  - Scrolled to top when truncation happens
  - Scrolled to bottom when truncation happens
  - Scrolled to middle when truncation happens
- Verify truncation marker always visible at top
- Ensure last line (exit code) always captured

**For Task 2.2 (Cancellation)**:
- Test on actual long-running processes (not just sleep)
- Verify no zombie processes left behind
- Test dialog rendering on small terminals
- Confirm SIGTERM works (not SIGKILL)
- Document Windows limitation clearly

---

## Testing Strategy

### Unit Tests
**Skip** - These are UI/UX improvements best verified manually

### Integration Tests
**Consider adding**:
```rust
#[test]
fn test_large_output_ring_buffer() {
    // Spawn command with 15,000 lines
    // Verify only last 10,000 kept
    // Verify truncation marker present
}
```

### Manual Testing (Primary)
**Test Suite**:
1. **Ring buffer**: `seq 1 15000` ‚Üí verify last 10K lines
2. **Cancellation**: `sleep 30` ‚Üí press q ‚Üí verify dialog ‚Üí press y ‚Üí verify stopped
3. **Error format**: `echo ok && exit 0` ‚Üí verify "‚úì Command completed successfully"
4. **Error format**: `exit 42` ‚Üí verify "‚úó Command failed with exit code 42"
5. **Edge case**: Multiple cancel attempts ‚Üí should only show dialog once
6. **Edge case**: Cancel after completion ‚Üí should close immediately

---

## Success Criteria

### Functional
- [ ] Ring buffer keeps last 10K lines, drops oldest
- [ ] Truncation clearly indicated with warning
- [ ] Long commands can be stopped with SIGTERM
- [ ] Confirmation dialog prevents accidental stops
- [ ] Error messages match spec exactly
- [ ] Exit code always visible

### Quality
- [ ] No crashes or panics
- [ ] No zombie processes
- [ ] Smooth scrolling after truncation
- [ ] Dialog renders correctly on all terminal sizes
- [ ] Unicode gracefully falls back to ASCII

### Process
- [ ] Each task tested individually before next
- [ ] Critique after each task (quick review)
- [ ] Comprehensive critique at end of Phase 2

---

## Deliverable

**Version**: v0.3.0 (or Phase 2 milestone)
**Tag**: High-priority UX improvements complete
**Status**: Production-ready command execution

**Release Notes**:
```
Phase 2: High Priority Fixes

- Added ring buffer for command output (keeps last 10K lines)
- Added command cancellation with SIGTERM (Unix)
- Fixed error message format to match specification
- Improved user feedback for long-running commands

Known Limitations:
- Command cancellation not supported on Windows (shows message)
- Ring buffer truncates earlier output (intentional, with warning)
```

---

## Dependencies

### External Crates
- `nix` = "0.27" (Unix only, for SIGTERM)
  - Features: `["signal"]`
  - Platform: `cfg(unix)`

### Internal
- ‚úÖ Phase 1 complete (command dispatch working)
- ‚úÖ All existing tests passing
- ‚úÖ No blocking issues

---

## Rollback Plan

If any task proves too complex or causes regressions:

1. **Revert commit** for problematic task
2. **Skip task** and document in notes
3. **Continue with remaining tasks**
4. **Defer complex task** to Phase 3

**Commit Strategy**:
- One commit per task (atomic)
- Clear commit messages: "feat(grove): implement output ring buffer (Task 2.1)"
- Enables easy revert if needed

---

## Documentation Updates

### During Implementation
- Update task status in this file
- Create critique after each task
- Document any issues encountered

### After Phase 2
- Create `2026-02-12-phase-2-complete.md`
- Update grove spec if behavior changed
- Document any deviations from plan

---

## Open Questions

### Task 2.1 (Ring buffer)
- ‚úÖ What line count limit? ‚Üí 10,000 lines (~1MB at 100 chars/line)
- ‚úÖ How many lines to drop at once? ‚Üí 1,000 lines (reduces churn)
- ‚ùì Should we save full output to file? ‚Üí Defer to Phase 3

### Task 2.2 (Cancellation)
- ‚úÖ SIGTERM or SIGKILL? ‚Üí SIGTERM (graceful)
- ‚úÖ Timeout before SIGKILL? ‚Üí No timeout (let user retry if needed)
- ‚ùì Track process group? ‚Üí Start with simple PID, enhance if needed

### Task 2.3 (Error format)
- ‚úÖ Unicode detection method? ‚Üí Use existing `supports_unicode()` if available
- ‚úÖ Where to show message? ‚Üí Output pane AND status bar

---

## Timeline

**Start**: 2026-02-12 (after Phase 1 complete)
**Estimated End**: Same day (+1h 45min)

| Task | Duration | Cumulative |
|------|----------|------------|
| 2.3 Error format | 15 min | 15 min |
| 2.1 Ring buffer | 30 min | 45 min |
| 2.2 Cancellation | 1 hour | 1h 45min |
| **Total** | **1h 45min** | |

**Buffer**: +30 min for unexpected issues (realistic: 2h 15min)

---

## Next Steps

1. ‚úÖ Planning complete (this document)
2. ‚è≠Ô∏è Implement Task 2.3 (error format) - 15 min
3. ‚è≠Ô∏è Quick critique of Task 2.3
4. ‚è≠Ô∏è Implement Task 2.1 (ring buffer) - 30 min
5. ‚è≠Ô∏è Quick critique of Task 2.1
6. ‚è≠Ô∏è Implement Task 2.2 (cancellation) - 1 hour
7. ‚è≠Ô∏è Comprehensive Phase 2 critique
8. ‚è≠Ô∏è Proceed to Phase 3 or wrap up

---

## Sources

- [Phase 1 Complete](2026-02-12-phase-1-complete.md) - Foundation for Phase 2
- [Improvement Plan](2026-02-12-command-dispatch-improvements-plan.md) - Original critique
- [Grove Specification](../docs/specifications/grove/grove-spec.md) - Error message format
- [Phase 1 Final Review](2026-02-12-phase-1-final-review.md) - Quality baseline
