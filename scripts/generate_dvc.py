#!/usr/bin/env python3
"""Generate dvc.yaml from *.prompt.md files"""
import sys, pathlib, re
try:
    import yaml
except ImportError:
    print("Missing PyYAML. Run: pip install pyyaml", file=sys.stderr); sys.exit(1)

ROOT = pathlib.Path(".").resolve()
DVC_YAML = ROOT / "dvc.yaml"

# Common script dependencies for all stages
# Implementation scripts are not tracked as dependencies to avoid
# expensive regeneration when only the tooling changes.
# Use `dvc repro -f` to force regeneration when needed.
SCRIPT_DEPS = []

def parse_frontmatter(prompt_path: pathlib.Path):
    """Extract deps from frontmatter"""
    txt = prompt_path.read_text(encoding="utf-8")
    m = re.match(r"^---\n(.*?)\n---\n", txt, re.S)
    if not m:
        return []
    meta = yaml.safe_load(m.group(1)) or {}
    deps = meta.get("deps") or []
    if not isinstance(deps, list):
        print(f"Warning: 'deps' must be a list in {prompt_path}", file=sys.stderr)
        return []
    return deps

def stage_name_from_path(prompt_path: pathlib.Path):
    """Convert path like 'docs/strategy/exec-summary.prompt.md' to 'exec_summary'"""
    # Remove .prompt.md and convert hyphens to underscores
    name = prompt_path.stem.replace(".prompt", "")
    return name.replace("-", "_")

def generate_stages():
    """Scan for all *.prompt.md files and generate stages"""
    stages = {}

    # Find all prompt files
    prompt_files = sorted(ROOT.glob("**/*.prompt.md"))

    if not prompt_files:
        print("Warning: No *.prompt.md files found", file=sys.stderr)
        return stages

    for prompt_path in prompt_files:
        # Get relative path
        rel_prompt = prompt_path.relative_to(ROOT).as_posix()

        # Parse frontmatter deps
        content_deps = parse_frontmatter(prompt_path)

        # Validate that deps exist
        for dep in content_deps:
            dep_path = ROOT / dep
            if not dep_path.exists():
                print(f"Warning: dep '{dep}' does not exist (from {rel_prompt})", file=sys.stderr)

        # Generate stage name
        stage_name = stage_name_from_path(prompt_path)

        # Output path: same dir, same base name, .md extension
        out_path = prompt_path.parent / f"{prompt_path.stem.replace('.prompt', '')}.md"
        rel_out = out_path.relative_to(ROOT).as_posix()

        # Build stage
        stage = {
            "cmd": (
                f"bash scripts/render_llm.sh "
                f"--prompt {rel_prompt} "
                f"--out {rel_out} "
                f"--name {stage_name}"
            ),
            "deps": SCRIPT_DEPS + [rel_prompt] + content_deps,
            "outs": [
                {rel_out: {"cache": False}}
            ]
        }

        stages[stage_name] = stage

    return stages

def main():
    """Generate dvc.yaml from prompt files"""
    stages = generate_stages()

    if not stages:
        print("No stages generated", file=sys.stderr)
        return 1

    # Generate dvc.yaml
    dvc_content = {
        "stages": stages
    }

    # Add header comment
    header = """# Generated by scripts/generate_dvc.py
# DO NOT EDIT MANUALLY - this file is auto-generated from *.prompt.md files
#
# To add a new document:
#   1. Create docs/<topic>/<name>.prompt.md
#   2. Add 'deps:' list in frontmatter
#   3. Run: bin/graft rebuild
#
# Each stage is generated from its corresponding .prompt.md file.
# Dependencies come from the 'deps:' field in frontmatter.

"""

    # Write dvc.yaml
    yaml_text = yaml.safe_dump(dvc_content, sort_keys=False, default_flow_style=False)
    DVC_YAML.write_text(header + yaml_text, encoding="utf-8")

    print(f"Generated {len(stages)} stage(s) in dvc.yaml")
    for name in sorted(stages.keys()):
        print(f"  - {name}")

    return 0

if __name__ == "__main__":
    sys.exit(main())
