<!-- Generated by Graft | model=bedrock-claude-v4.5-sonnet-us | sig=b21a4c18ca0d342468ff1fe53314190c7ba0682202d1f6fd57626aa16ccd0579 | rev=49e52c7 | 2025-11-04 -->
# How It Works - Technical Architecture

This document explains Graft's internal architecture, change detection mechanisms, and pipeline management system.

## Architecture Overview

Graft consists of five core components that work together to create a documentation pipeline:

1. **Source documents**: Markdown files, code, data, or any text that serves as input material for documentation generation.

2. **Prompt files**: Files ending in `.prompt.md` that contain instructions for the LLM and frontmatter declaring dependencies, model parameters, and output locations.

3. **Pack prompt (change detection)**: The `scripts/pack_prompt.py` script that detects what changed (sources vs. instructions), generates unified diffs, and creates a packed prompt with the appropriate action directive for the LLM.

4. **Render (LLM invocation)**: The `scripts/render.py` script that sends the packed prompt to Claude, receives the response, and handles API communication including retry logic and error handling.

5. **Generate (output creation)**: The final stage where rendered output is written to disk at the location specified in the prompt's frontmatter, creating documentation that can itself become input to other prompts.

**Component Flow:**

```
Source Docs + Prompt File
         ↓
    pack_prompt.py (detects changes, creates directive)
         ↓
    render.py (invokes Claude API)
         ↓
    Generated Output (tracked in git)
         ↓
    (can be input to other prompts)
```

## Change Detection

Graft tracks two independent types of changes to determine how documentation should be regenerated:

### Source Changes

Source changes are detected by running `git diff` on all files listed in the `deps:` frontmatter section. The detection logic in `pack_prompt.py` (lines ~80-95) uses:

```bash
git diff HEAD -- <source_files>
```

If any dependencies have uncommitted changes, `sources_changed` is set to `True` and a unified diff is generated showing exactly what changed in the source material.

### Prompt Changes

Prompt changes are detected by comparing the current prompt body (everything after the frontmatter) with the version from the previous commit. The logic (lines ~97-112) uses:

```bash
git show HEAD:<prompt_file>
```

Then extracts and compares just the prompt body content, ignoring the frontmatter (which contains metadata like model parameters, not instructions). If the instruction text differs, `prompt_changed` is set to `True` and a unified diff is generated showing what changed in the instructions.

### Previous Draft Loading

The previous draft is always loaded from git HEAD (lines ~118-120), not from the filesystem. This ensures reproducible builds based on committed state, even if the working directory contains uncommitted changes to the output file. If the file doesn't exist in git (first generation), the previous draft is an empty string.

### Packed Prompt Structure

When changes are detected, `pack_prompt.py` creates a packed prompt containing:

1. **System message**: Explains the change detection model and defines all five action directives
2. **Change analysis**: States which types of changes occurred and which action is required
3. **Previous draft**: The existing output document from git HEAD (if any)
4. **Source diff** (if sources changed): Unified diff showing semantic changes in source material
5. **Prompt diff** (if instructions changed): Unified diff showing what changed in the instructions
6. **Current instructions**: The full prompt body with current requirements
7. **Source content**: Full text of all dependency files

This structure gives Claude complete context to apply the requested action intelligently.

## Actions and Directives

The action selection logic (defined in `pack_prompt.py:117-134`) determines which directive to pass to Claude based on what changed:

### GENERATE

**When**: No previous draft exists (output file not present)

**Why**: Initial creation requires generating the full document from scratch using the source content and instructions.

**Logic**: `if not output_exists`

### UPDATE

**When**: Sources changed but prompt instructions haven't

**Why**: Source material has new information, but the structure and style requirements remain the same. Claude should apply only the semantic changes from the source diff while keeping all other sections byte-identical.

**Logic**: `elif sources_changed and not prompt_changed`

**Emphasis**: This directive explicitly instructs Claude to preserve all unchanged content exactly, modifying only sections affected by source changes.

### REFINE

**When**: Prompt instructions changed but sources haven't

**Why**: The requirements, structure, or presentation have changed, but the underlying source material is the same. Claude should review the prompt diff to understand what changed and apply only the necessary modifications to align the document with updated instructions.

**Logic**: `elif prompt_changed and not sources_changed`

**Emphasis**: The scope of changes depends on what changed in the instructions. A factual correction (e.g., fixing a license name) requires only a line change. A style directive (e.g., "rewrite in formal tone") requires broader changes. Claude uses semantic judgment based on the diff content.

### REFRESH

**When**: Both sources and prompt instructions changed

**Why**: The document needs updates from both source changes and instruction changes. Claude must review both diffs carefully and apply only the necessary changes from each.

**Logic**: `elif sources_changed and prompt_changed`

**Emphasis**: This combines UPDATE and REFINE approaches—apply semantic source changes AND necessary instruction-driven modifications while preserving unchanged content.

### MAINTAIN

**When**: Neither sources nor instructions changed

**Why**: No changes detected means the output should remain identical to prevent spurious diffs.

**Logic**: `else` (neither `sources_changed` nor `prompt_changed`)

**Emphasis**: Output must be byte-identical to previous draft.

### Intelligent Application

These directives are passed to Claude via the system message. Claude interprets them intelligently based on:

- The specific changes shown in the diffs
- The semantic meaning of those changes
- The structure and content of the existing document
- The requirements stated in the current instructions

This approach combines precise change detection with flexible AI interpretation.

## Multi-level Documentation DAGs

Graft supports hierarchical documentation where generated documents become inputs to other prompts, creating a directed acyclic graph (DAG) of dependencies.

### How It Works

A prompt's `deps:` section can reference any file tracked in git, including outputs from other prompts. DVC automatically understands the dependency relationships and manages the cascade of updates.

### Concrete Example

Consider a three-level documentation hierarchy:

```
docs/api-reference.md (source code analysis)
         ↓ (input to)
docs/user-guide.md (references API structure)
         ↓ (input to)
docs/overview.md (high-level summary)
```

**File structure:**

```
docs/
├── api-reference.prompt.md
│   deps: ["src/**/*.py"]
│   out: api-reference.md
├── user-guide.prompt.md
│   deps: ["docs/api-reference.md", "examples/**/*.py"]
│   out: user-guide.md
└── overview.prompt.md
    deps: ["docs/api-reference.md", "docs/user-guide.md"]
    out: overview.md
```

**Change propagation:**

If `src/api.py` changes:
1. DVC detects that `api-reference.md` depends on `src/**/*.py`
2. Regenerates `api-reference.md` via UPDATE action
3. Detects that `user-guide.md` depends on `api-reference.md`
4. Regenerates `user-guide.md` via UPDATE action
5. Detects that `overview.md` depends on both changed files
6. Regenerates `overview.md` via UPDATE action

### DVC Efficiency

DVC manages this efficiently through:

- **`cache: false` for outputs**: Prompt outputs are stored only in the working directory and git, not duplicated in DVC's cache (configured in `scripts/generate_dvc_yaml.py:75`)
- **Git-tracked files**: Generated documents are committed to git, making them directly accessible as dependencies
- **Change cascades**: DVC's dependency graph automatically propagates changes through multiple levels
- **Selective regeneration**: Only stages with changed dependencies are re-executed; unchanged branches of the DAG are skipped

This allows complex documentation hierarchies without manual orchestration or cache bloat.

## Auto-generated dvc.yaml

The `dvc.yaml` file defining the pipeline is automatically generated by scanning for `*.prompt.md` files. **Never edit dvc.yaml manually**—it will be overwritten.

### Generation Process

The `scripts/generate_dvc_yaml.py` script (invoked by `bin/graft repro` and `bin/graft sync`) performs these steps:

1. **Scan for prompts**: Uses `glob.glob("**/*.prompt.md", recursive=True)` to find all prompt files

2. **Parse frontmatter**: Extracts YAML frontmatter from each prompt containing:
   - `out`: Output file path
   - `deps`: List of dependency files/globs
   - `model`: Claude model identifier (default: "claude-3-7-sonnet-20250219")
   - `max_tokens`: Token limit (default: 16000)
   - `temperature`: Sampling temperature (default: 1.0)

3. **Create DVC stage**: Each prompt becomes a stage named after its output path:
   ```yaml
   docs/how-it-works.md:
     cmd: scripts/render.py docs/how-it-works.prompt.md
     deps:
     - docs/how-it-works.prompt.md
     - scripts/pack_prompt.py
     - <files from prompt's deps>
     outs:
     - docs/how-it-works.md:
         cache: false
   ```

4. **Include pack_prompt.py**: The packing script is automatically added as a dependency for every stage since changes to change detection logic affect all outputs

5. **Model parameters**: Passed as command-line arguments to `render.py`:
   ```
   --model claude-3-7-sonnet-20250219
   --max-tokens 16000
   --temperature 1.0
   ```

6. **Output co-location**: Outputs are placed according to the `out:` field, typically alongside the prompt file or in a logical documentation location

### Synchronization

Running `bin/graft sync` regenerates `dvc.yaml` from current `*.prompt.md` files, ensuring the pipeline definition stays synchronized with prompt declarations.

## Git Hooks

Graft installs a pre-commit hook (`.git/hooks/pre-commit` created by `scripts/setup_git_hooks.py`) that prevents common desynchronization issues.

### What It Detects

The hook runs before each commit and checks:

1. **dvc.yaml is current**: Compares actual `*.prompt.md` files against `dvc.yaml` stages
2. **Outputs are up-to-date**: Runs `dvc status` to detect if any outputs need regeneration

### What It Does

If issues are detected:

- **Missing stages**: Prompts exist but aren't in `dvc.yaml` → blocks commit with message to run `bin/graft sync`
- **Stale outputs**: DVC reports outputs need regeneration → blocks commit with message to run `bin/graft repro`
- **Everything current**: Allows commit to proceed

### Why This Matters

Without the hook, developers could:
- Add a `.prompt.md` file but forget to update `dvc.yaml` → pipeline doesn't execute
- Modify sources but forget to regenerate outputs → documentation becomes stale
- Commit inconsistent state → breaks reproducibility

The hook enforces that committed state is always complete and consistent.

## Docker Execution

All Graft commands execute inside a Docker container for consistency and reproducibility.

### Benefits

1. **Consistent environment**: Python version, dependencies, and tool versions are locked via `Dockerfile`
2. **No local setup**: Developers don't need to install Python, DVC, or configure environments
3. **Reproducible builds**: Same container image produces identical results across machines
4. **Isolation**: Graft's dependencies don't conflict with project dependencies
5. **Credential security**: API keys are mounted at runtime, never baked into images

### How It Works

The `bin/graft` script handles Docker invocation transparently:

1. **Build/pull image**: Ensures the `graft` Docker image exists and is current
2. **Mount working directory**: `-v "$(pwd):/workspace"` makes project files accessible
3. **Mount credentials**: `-v "$HOME/.config/graft:/root/.config/graft:ro"` provides read-only access to API keys
4. **Set working directory**: `-w /workspace` ensures relative paths work correctly
5. **Execute command**: Runs the requested Graft command (sync, repro, etc.) inside the container

Example invocation:
```bash
bin/graft repro
# Translates to:
docker run --rm \
  -v "$(pwd):/workspace" \
  -v "$HOME/.config/graft:/root/.config/graft:ro" \
  -w /workspace \
  graft \
  scripts/generate_dvc_yaml.py && dvc repro
```

From the user's perspective, `bin/graft` behaves like a native command, but all execution happens in the controlled Docker environment.
