<!-- Generated by Graft | model=bedrock-claude-v4.5-sonnet-us | sig=eb877070e26dcb106d8acee57f48def4d45f38a956e8f3fcca28343059803197 | rev=4b99e8d | 2025-11-04 -->
# Graft Use Cases: Organizational Knowledge Management

Graft is a git-native knowledge management system that enables organizations to maintain living, interconnected knowledge where documents reference other documents as sources, changes propagate through dependency graphs with surgical edits, and teams review and approve how knowledge evolves through standard PR workflows.

The unique power: **Any document can depend on any other document.** You design the dependency graph to match how knowledge flows in your organization. When sources change, dependent documents update surgically—not full regeneration, but specific, reviewable edits. Teams discuss these changes in PRs, approve or adjust them, and build consensus on how knowledge propagates. The entire system is git-backed, human-auditable, and enables workflows that traditional documentation tools cannot support.

This isn't just documentation generation—it's organizational alignment machinery. Strategic principles cascade through abstraction layers to guide implementation, but knowledge also flows upward: meeting notes inform policies, incidents inform runbooks, technical constraints inform strategy, code realities shape architecture decisions. Different stakeholders work at appropriate abstraction levels while everything stays synchronized. Git provides full auditability showing how organizational knowledge evolved and why.

The following use cases demonstrate how organizations use Graft to maintain living policies, enable cross-functional alignment, build team consensus on knowledge propagation, and create organizational memory that stays current without manual synchronization.

## Core Use Cases

### 1. Living Team Agreements Referenced to Meeting Notes

**The Problem**: Team working agreements become outdated. Meeting discussions produce action items, but the team handbook never gets updated. Six months later, nobody remembers what was decided or why.

**The Solution**: Working agreements depend on meeting notes as source documents. When meetings produce decisions, the agreement updates surgically with full traceability to the source discussion.

**The Structure**:

```yaml
# docs/team/working-agreement.prompt.md
---
deps:
  - docs/meetings/2025-01-15-team-retro.md
  - docs/meetings/2025-02-03-process-discussion.md
  - docs/meetings/2025-02-20-code-review-discussion.md
model: bedrock-claude-v4.5-sonnet-us
---

Create our team working agreement by synthesizing decisions and action items 
from team meetings. Each section should reference the meeting where it was 
decided. Maintain clear, actionable guidelines.

Structure:
- Communication norms
- Code review expectations
- On-call responsibilities
- Decision-making process

For each guideline, include: [Decided: meeting date] to maintain traceability.
```

**The Workflow**:

1. **Team meeting produces action item**: The 2025-02-20 code review discussion concludes: "We should clarify our code review expectations—specifically around response times and blocking vs. non-blocking feedback."

2. **Meeting notes added to git**:
```markdown
# 2025-02-20 Code Review Discussion

## Attendees
[...]

## Decisions
- Code reviews should get initial response within 24 hours
- Blocking feedback must include specific concerns and suggestions
- Non-blocking feedback should be clearly marked with "nit:" prefix
- Reviewers should approve after addressing blocking feedback

## Action Items
- [ ] Update team working agreement with these expectations
```

3. **Working agreement depends on this meeting** (listed in deps), so `bin/graft rebuild` triggers an UPDATE action:

```diff
# Team Working Agreement

## Code Review Expectations

-Code reviews should be timely and constructive.
+Code reviews should get an initial response within 24 hours. [Decided: 2025-02-20]

+**Blocking Feedback**: Must include specific concerns and concrete suggestions for 
+improvement. Reviewers should approve after blocking feedback is addressed.
+[Decided: 2025-02-20]

+**Non-Blocking Feedback**: Should be clearly marked with "nit:" prefix to indicate 
+it's optional. Examples: "nit: consider extracting this to a helper function" 
+[Decided: 2025-02-20]

[Rest of document unchanged]
```

4. **Team reviews the PR**:
   - Engineer: "The 24-hour expectation feels tight during on-call rotations. Should we say '24 hours or communicate expected delay'?"
   - Team lead: "Good point. Let's adjust the meeting notes to reflect that nuance."
   - Engineer updates meeting notes with refinement
   - `bin/graft rebuild` generates new surgical edit
   - Team approves PR with refined language

5. **Result**: 
   - Working agreement stays current with team decisions
   - Every guideline traces back to the meeting where it was decided
   - Git history shows: when it was decided, who participated, how it evolved
   - Team consensus built through PR review, not unilateral updates

**The Key Insight**: Surgical edits enable meaningful team discussion. Not "the system regenerated the entire document"—specific, reviewable changes that teams can discuss, refine, and approve. The meeting notes serve as auditable sources for policy decisions. When teams want to revisit a policy, they can trace it back to the original discussion and context.

**Variations**:
- Retrospectives → Team processes
- Incident post-mortems → Runbooks
- Architecture discussions → Design principles
- Customer feedback sessions → Product requirements

### 2. Strategic Principles Cascading to Implementation

**The Problem**: Leadership announces strategic values, but they never translate to concrete practices. Engineering teams don't know how "focus on sustainability" affects their daily work. Six months later, nothing changed because nobody knew what to do differently.

**The Solution**: A four-level hierarchy where principles cascade through abstraction layers, with each level reviewed by appropriate stakeholders who discuss how principles apply to their domain.

**The Structure**:

```
docs/company/values.md (manual, leadership-owned)
  └─> docs/engineering/principles.prompt.md
      └─> docs/platform/design-patterns.prompt.md
          └─> docs/standards/code-guidelines.prompt.md
```

Each level depends on the previous one:

```yaml
# docs/engineering/principles.prompt.md
---
deps:
  - docs/company/values.md
---

Translate company values into engineering principles that guide technical 
decision-making. Each principle should reference its source value and explain 
how it applies to engineering work.
```

```yaml
# docs/platform/design-patterns.prompt.md
---
deps:
  - docs/engineering/principles.md
---

Define platform design patterns that operationalize our engineering principles. 
Each pattern should reference the principle it serves and provide concrete 
examples relevant to our microservices architecture.
```

```yaml
# docs/standards/code-guidelines.prompt.md
---
deps:
  - docs/platform/design-patterns.md
---

Create coding standards that implement our design patterns. Provide specific, 
enforceable guidelines with code examples. Each guideline should trace back 
to the pattern it implements.
```

**The Workflow**:

1. **Leadership adds new company value**:

```markdown
# Company Values

## Customer Obsession
[existing content]

## Innovation
[existing content]

## Sustainability
We are committed to building sustainable systems—technically, environmentally, 
and economically. This means:
- Technical: Systems that can be maintained long-term without heroic effort
- Environmental: Minimizing our environmental footprint
- Economic: Efficient use of resources that scales cost-effectively
```

2. **Engineering principles document depends on values**, triggers UPDATE:

```diff
# Engineering Principles

+## Sustainable System Design
+Derived from company value: Sustainability
+
+Build systems that can be maintained long-term without heroic effort:
+- Favor simple solutions over clever ones
+- Design for operational sustainability (observability, debuggability)
+- Consider total cost of ownership, not just initial development cost
+- Minimize resource consumption (compute, memory, network)
+
+[Principle traces to: Company Values > Sustainability]

[Rest of document unchanged]
```

3. **Leadership reviews PR at this level**:
   - CTO: "This captures the technical sustainability angle well. Should we add something about knowledge sustainability—documentation and onboarding?"
   - Engineering director: "Yes, and we should mention avoiding technical debt that creates maintenance burden."
   - Values document refined, principles regenerate with updates
   - Leadership approves

4. **Design patterns document depends on principles**, cascades the change:

```diff
# Platform Design Patterns

+## Resource-Efficient Service Design
+Implements principle: Sustainable System Design
+
+Design services to minimize resource consumption while maintaining performance:
+
+**Pattern: Right-Sized Compute**
+- Profile actual resource usage before scaling
+- Use auto-scaling based on real metrics, not guesses
+- Consider serverless for intermittent workloads
+- Document resource requirements for capacity planning
+
+**Pattern: Efficient Data Access**
+- Cache appropriately (but not prematurely)
+- Use connection pooling
+- Implement pagination for large datasets
+- Consider read replicas for read-heavy workloads
+
+[Pattern traces to: Engineering Principles > Sustainable System Design]

[Rest of document unchanged]
```

5. **Platform team reviews PR at this level**:
   - Platform engineer: "The right-sized compute pattern is good, but we should add guidance about our monitoring thresholds."
   - Architect: "Also, the connection pooling guidance should reference our standard connection pool library."
   - Discussion leads to refinements in the patterns document
   - Platform team approves with context-specific details

6. **Code standards document depends on patterns**, cascades further:

```diff
# Code Standards

+## Resource Efficiency Standards
+Implements pattern: Resource-Efficient Service Design
+
+**Database Connections**
+```python
+# Use the standard connection pool (max_size=20, min_size=5)
+from platform.db import get_connection_pool
+
+pool = get_connection_pool()
+async with pool.acquire() as conn:
+    # Use connection
+```
+
+**Pagination Requirements**
+All list endpoints must implement pagination with default page size of 50:
+```python
+@app.get("/items")
+async def list_items(page: int = 1, page_size: int = 50):
+    if page_size > 100:
+        raise ValueError("page_size must not exceed 100")
+    # Implementation
+```
+
+[Standard implements: Platform Patterns > Resource-Efficient Service Design]

[Rest of document unchanged]
```

7. **Development team reviews PR at this level**:
   - Developer: "The connection pool settings make sense for our API services, but our batch jobs need different settings. Should we have separate guidance?"
   - Tech lead: "Good catch. Let's add a section distinguishing between service and batch job patterns."
   - Standards refined to handle nuance
   - Team approves with job-specific context

**Result**:
- Company value "Sustainability" cascaded through 4 levels of abstraction
- Each level reviewed by appropriate stakeholders who provided domain expertise
- Leadership sees strategic intent preserved
- Engineers see concrete, actionable standards
- Full traceability: every guideline traces back through patterns, principles, to original value
- Git history shows how the organization operationalized a strategic value

**The Key Insight**: First principles propagation with human oversight at each layer. The cascade isn't automatic—it's guided. Each team reviews how principles apply to their domain, discusses implications, adds context-specific details, and approves when it's right. This builds organizational alignment where strategic values become tactical reality, but with team consensus at every step.

**Variations**:
- Security principles → Threat models → Security controls → Code standards
- Product vision → Product strategy → Feature roadmap → Implementation tasks
- Design system principles → Component guidelines → Code patterns → PR templates

### 3. Architecture Decisions with Progressive Synthesis

**The Problem**: Architecture Decision Records (ADRs) proliferate. Each team makes local decisions, but nobody knows how they fit together. Leadership wants to understand technical strategy, but reading 50 ADRs isn't feasible. Meanwhile, engineers need to know how decisions in other domains affect their work.

**The Solution**: Multi-level synthesis where ADRs feed domain architectures, which feed system overview, which feeds executive strategy. Each stakeholder sees the appropriate abstraction level, but everything stays synchronized.

**The Structure**:

```
docs/decisions/adr-*.md (individual ADRs, manually written)
  └─> docs/architecture/domain-*.prompt.md (synthesize ADRs by domain)
      └─> docs/architecture/system-overview.prompt.md (synthesize all domains)
          └─> docs/strategy/technical-strategy.prompt.md (executive summary)
```

Example domain architecture:

```yaml
# docs/architecture/domain-backend-services.prompt.md
---
deps:
  - docs/decisions/adr-015-service-mesh.md
  - docs/decisions/adr-018-event-driven-integration.md
  - docs/decisions/adr-022-service-communication.md
  - docs/decisions/adr-025-api-versioning.md
model: bedrock-claude-v4.5-sonnet-us
---

Synthesize backend services architecture from relevant ADRs. Create a coherent 
narrative that explains:
- How services communicate
- Integration patterns
- Versioning strategy
- Key trade-offs and constraints

Target audience: Backend engineers who need to understand current architecture 
and how decisions relate to each other.

For each architectural element, reference the ADR where it was decided.
```

System overview:

```yaml
# docs/architecture/system-overview.prompt.md
---
deps:
  - docs/architecture/domain-backend-services.md
  - docs/architecture/domain-data-platform.md
  - docs/architecture/domain-frontend.md
  - docs/architecture/domain-infrastructure.md
---

Create a system-wide architecture overview that synthesizes domain architectures 
into a coherent picture of how our entire system works. Explain how domains 
interact and highlight cross-domain patterns.

Target audience: Architects and senior engineers who need to understand the 
complete system.
```

Executive strategy:

```yaml
# docs/strategy/technical-strategy.prompt.md
---
deps:
  - docs/architecture/system-overview.md
---

Create an executive technical strategy brief that extracts key strategic 
directions from our architecture. Focus on:
- Strategic technical bets we're making
- Architecture qualities we're prioritizing
- Key technical capabilities we're building
- Strategic risks and mitigation approaches

Target audience: Non-technical leadership. Avoid implementation details.
```

**The Workflow**:

1. **New ADR added**: Backend team decides to adopt gRPC for synchronous service-to-service communication.

```markdown
# ADR-022: gRPC for Service-to-Service Communication

## Status
Accepted

## Context
Our microservices currently use REST for all communication. We're experiencing 
issues with schema drift, verbose JSON payloads, and lack of type safety.

## Decision
Adopt gRPC with Protocol Buffers for synchronous service-to-service communication.
REST remains for external APIs.

## Consequences
- Strong typing and schema enforcement
- More efficient binary protocol
- Better tooling for API contracts
- Learning curve for team
- Need to maintain both REST and gRPC infrastructure
```

2. **Domain architecture depends on ADRs**, gets surgical update:

```diff
# Backend Services Architecture

## Service Communication Patterns

-Services communicate primarily via REST APIs for synchronous operations and 
-Kafka events for asynchronous integration.
+Services use gRPC with Protocol Buffers for synchronous service-to-service 
+communication, providing strong typing and schema enforcement. REST APIs are 
+maintained for external-facing endpoints. Asynchronous integration continues 
+to use Kafka events. [Decided: ADR-022]

+### gRPC Communication Pattern
+Internal services communicate via gRPC for:
+- Strong API contracts with Protocol Buffers
+- Type safety across service boundaries
+- Efficient binary protocol
+
+Key implementation details:
+- Proto files maintained in shared repository
+- Generated clients for each service
+- gRPC health checks integrated with service mesh
+
+[Pattern established: ADR-022]

## Event-Driven Integration
[Existing content referencing ADR-018 unchanged]

[Rest of document unchanged]
```

3. **Backend team reviews PR**:
   - Engineer: "Should we mention the shared proto repository setup? That's a critical implementation detail."
   - Architect: "Yes, and we should clarify that REST remains for external APIs—don't want people thinking we're deprecating public REST endpoints."
   - ADR refined to clarify scope
   - Domain architecture regenerates with clarifications
   - Team approves

4. **System overview depends on domain architectures**, cascades:

```diff
# System Architecture Overview

## Cross-Domain Communication

-System components communicate through a combination of synchronous REST APIs 
-and asynchronous event streaming via Kafka.
+System components use protocol-appropriate communication patterns:
+- **Internal service communication**: gRPC with Protocol Buffers for strong 
+  typing and efficient binary protocol [Backend Services Architecture]
+- **External APIs**: REST for client-facing endpoints [Backend Services Architecture]
+- **Asynchronous integration**: Kafka event streaming [Data Platform Architecture]

+This hybrid approach balances type safety and efficiency for internal 
