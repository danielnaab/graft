<!-- Generated by Graft | model=bedrock-claude-v4.5-sonnet-us | sig=b0b2573ed6b7a4b4f37915d156cb540fef7c2a0aa083174aa6cc08897bbc9a25 | rev=4155622 | 2025-11-04 -->
# GitHub Integration Workflow Patterns

This document specifies comprehensive workflow patterns for GitHub + Graft integration, detailing how developers, reviewers, CI systems, and Claude Code interact with Graft to maintain living documentation.

## Developer Workflows

### Pattern: Local Iteration

**Actor**: Developer

**Trigger**: Developer modifies source files or prompt instructions

**Preconditions**:
- Working git repository with Graft configured
- `.graft/` directory with prompt files
- Previous draft committed to git (or first generation)

**Steps**:

1. **Edit sources or prompts**
   ```bash
   # Edit source material
   vim src/pipeline.py
   
   # Or edit prompt instructions
   vim .graft/docs/how-it-works.md.prompt
   ```

2. **Regenerate affected documents**
   ```bash
   graft regenerate docs/how-it-works.md
   ```
   
   Expected output:
   ```
   Analyzing changes...
   - Source files changed: YES (1 file)
   - Prompt changed: NO
   - Action: UPDATE
   
   Generating docs/how-it-works.md...
   Cost: $0.023 | Tokens: 4,521 in / 1,834 out | Time: 3.2s
   ✓ Generated docs/how-it-works.md
   ```

3. **Review generated changes**
   ```bash
   git diff docs/how-it-works.md
   ```
   
   Examine diff to verify:
   - Only relevant sections updated
   - Unchanged sections preserved exactly
   - New content accurately reflects source changes

4. **Iterate if needed**
   - If output is wrong: Refine prompt instructions
   - If sources unclear: Update source material
   - Re-run `graft regenerate` until satisfied

5. **Commit when satisfied**
   ```bash
   git add src/pipeline.py docs/how-it-works.md
   git commit -m "feat: add previous draft loading from git HEAD
   
   - Load draft from git, not filesystem
   - Update architecture docs"
   ```

**Artifacts**:
- Modified source files (if sources changed)
- Modified prompt files (if instructions changed)
- Regenerated output documents
- Git commit with all changes

**Success Criteria**:
- Generated document accurately reflects changes
- `graft validate` passes
- Diff shows surgical edits only
- Developer confident in changes

**Error Scenarios**:

| Error | Cause | Resolution |
|-------|-------|-----------|
| "Source file not in git" | New file not staged | `git add` the source file |
| "Prompt file missing" | No prompt configured | `graft init docs/how-it-works.md` |
| "API rate limit" | Too many requests | Wait 60s, retry |
| "Hallucinated content" | Prompt too vague | Add specific constraints to prompt |
| "Over-broad changes" | Wrong action directive | Check change detection logic, refine prompt |

**Performance Characteristics**:
- Time: 2-5s per document (depends on length)
- Cost: $0.01-0.05 per generation (depends on sources)
- Parallel: Can regenerate independent docs simultaneously
- Incremental: Only regenerates when dependencies change

**Integration Points**:
- Connects to **PR Preparation** when ready to push
- Feeds into **Quick Validation** for confidence checks
- Supports **Assisted Authoring** with Claude Code

---

### Pattern: PR Preparation

**Actor**: Developer

**Trigger**: Developer ready to push changes to GitHub

**Preconditions**:
- Local changes committed to feature branch
- All affected documents regenerated
- Working CI configuration

**Steps**:

1. **Validate all documents**
   ```bash
   graft validate --all
   ```
   
   Expected output:
   ```
   Validating 12 documents...
   ✓ docs/how-it-works.md (up to date)
   ✓ docs/use-cases.md (up to date)
   ✓ docs/architecture.md (up to date)
   ...
   
   All documents valid. Safe to push.
   ```

2. **Check for stale documents**
   ```bash
   graft status
   ```
   
   Expected output:
   ```
   Status of Graft-managed documents:
   
   Up to date (10):
     docs/how-it-works.md
     docs/use-cases.md
     ...
   
   Stale (2):
     docs/api-reference.md (sources changed)
     README.md (prompt changed)
   
   Run: graft regenerate docs/api-reference.md README.md
   ```

3. **Regenerate any stale documents**
   ```bash
   graft regenerate docs/api-reference.md README.md
   git add docs/api-reference.md README.md
   git commit -m "docs: regenerate stale documents"
   ```

4. **Preview CI behavior locally**
   ```bash
   # Run the same validation CI will run
   .github/scripts/validate-graft.sh
   ```
   
   This ensures CI will pass before pushing.

5. **Push to GitHub**
   ```bash
   git push origin feature/previous-draft-from-git
   ```

6. **Open PR with context**
   
   PR description should include:
   ```markdown
   ## Changes
   - Added previous draft loading from git HEAD
   - Ensures reproducible builds from committed state
   
   ## Documentation Impact
   Regenerated:
   - docs/how-it-works.md (added "Previous Draft Loading" section)
   - docs/use-cases.md (sig update only, no content change)
   
   All docs validated locally. CI should pass.
   ```

**Artifacts**:
- Clean commit history on feature branch
- All generated docs up to date
- Validation passing locally
- PR with clear description

**Success Criteria**:
- `graft validate --all` passes
- `graft status` shows no stale documents
- PR description explains documentation impact
- Developer confident CI will pass

**Error Scenarios**:

| Error | Cause | Resolution |
|-------|-------|-----------|
| "Validation failed" | Stale documents exist | Run `graft status`, regenerate stale docs |
| "Uncommitted changes" | Forgot to commit | `git add` and commit regenerated docs |
| "Dependency changed" | Upstream doc updated | Regenerate dependent docs |
| "CI config missing" | No .github/workflows | Add CI workflow file |

**Performance Characteristics**:
- Time: 10-30s for full validation (depends on doc count)
- Cost: $0 (validation is local comparison)
- One-time: Only needed before push
- Cached: Git operations leverage existing index

**Integration Points**:
- Follows **Local Iteration** cycle
- Triggers **Validation on Push** CI workflow
- Enables **Context Building** for reviewers
- May involve **Assisted Authoring** for PR description

---

### Pattern: PR Response

**Actor**: Developer

**Trigger**: Reviewer requests changes to documentation

**Preconditions**:
- Open PR with review comments
- Reviewer identified specific issues with generated docs
- Developer has local feature branch

**Steps**:

1. **Understand review feedback**
   
   Example review comment:
   ```
   The "Previous Draft Loading" section is good, but it doesn't 
   explain *why* we load from git instead of filesystem. Can you 
   add the rationale?
   ```

2. **Identify root cause**
   
   Determine whether to fix:
   - **Prompt instructions**: If doc structure/approach is wrong
   - **Source material**: If factual content is missing
   - **Both**: If both need updates

3. **Update appropriate files**
   
   For this example, update the prompt:
   ```bash
   vim .graft/docs/how-it-works.md.prompt
   ```
   
   Add to instructions:
   ```markdown
   When explaining previous draft loading, emphasize WHY 
   we load from git (reproducible builds, consistent with 
   committed state) rather than just HOW.
   ```

4. **Regenerate with new instructions**
   ```bash
   graft regenerate docs/how-it-works.md
   ```
   
   Expected output shows prompt changed:
   ```
   Analyzing changes...
   - Source files changed: NO
   - Prompt changed: YES
   - Action: REFINE
   
   Generating docs/how-it-works.md...
   ✓ Generated docs/how-it-works.md
   ```

5. **Review changes address feedback**
   ```bash
   git diff docs/how-it-works.md
   ```
   
   Verify new content explains the rationale.

6. **Commit and push**
   ```bash
   git add .graft/docs/how-it-works.md.prompt docs/how-it-works.md
   git commit -m "docs: explain rationale for git-based draft loading"
   git push origin feature/previous-draft-from-git
   ```

7. **Respond to review**
   
   Comment on PR:
   ```
   Updated! I refined the prompt to emphasize the "why" and 
   regenerated. The section now explains that git-based loading 
   ensures reproducible builds based on committed state.
   ```

**Artifacts**:
- Updated prompt instructions (if prompt issue)
- Updated source material (if source issue)
- Regenerated documentation
- New commit addressing feedback
- Response comment on PR

**Success Criteria**:
- Generated content addresses reviewer's concern
- Changes are surgical (only affected section updated)
- Validation still passes
- Reviewer satisfied with update

**Error Scenarios**:

| Error | Cause | Resolution |
|-------|-------|-----------|
| "Prompt too complex" | Too many constraints | Simplify, trust model judgment |
| "Still not right" | Wrong root cause identified | Try updating different file (prompt vs source) |
| "Over-rewrote" | Prompt change too broad | Make prompt change more specific |
| "Introduced errors" | Prompt poorly worded | Review prompt diff, clarify instructions |

**Performance Characteristics**:
- Time: 5-10 minutes per feedback item
- Cost: $0.01-0.05 per regeneration
- Iterations: Usually 1-2 cycles to address feedback
- Parallelizable: Multiple docs can be updated independently

**Integration Points**:
- Follows **Context Building** review
- Uses **Local Iteration** workflow
- May trigger **Preview Generation** on push
- Leads to **Approval Decision**

---

## CI/CD Workflows

### Pattern: Validation on Push

**Actor**: CI System (GitHub Actions)

**Trigger**: Push to any branch or PR opened/updated

**Preconditions**:
- Repository has `.github/workflows/graft-validate.yml`
- Graft installed in CI environment
- Source files and prompts in repository

**Steps**:

1. **CI workflow triggers**
   
   `.github/workflows/graft-validate.yml`:
   ```yaml
   name: Validate Graft Docs
   
   on:
     push:
       branches: ["**"]
     pull_request:
       types: [opened, synchronize]
   
   jobs:
     validate:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
           with:
             fetch-depth: 0  # Need full history for git-based comparison
         
         - name: Install Graft
           run: pip install graft
         
         - name: Validate all documents
           run: graft validate --all
         
         - name: Check for stale documents
           run: |
             if graft status | grep -q "Stale"; then
               echo "❌ Stale documents found"
               graft status
               exit 1
             fi
   ```

2. **Validation runs**
   
   For each Graft-managed document:
   - Load previous draft from git HEAD
   - Detect changes in sources and prompts
   - Compare expected action vs committed state
   - Report any mismatches

3. **Status reported**
   
   Success output:
   ```
   ✓ docs/how-it-works.md (up to date)
   ✓ docs/use-cases.md (up to date)
   ✓ README.md (up to date)
   
   All documents valid.
   ```
   
   Failure output:
   ```
   ✗ docs/api-reference.md (stale)
     Sources changed but document not regenerated
     Run: graft regenerate docs/api-reference.md
   
   Validation failed. Please regenerate stale documents.
   ```

4. **GitHub status check updates**
   
   GitHub shows check result on PR:
   - ✓ Green check: All docs valid
   - ✗ Red X: Stale docs found
   
   Blocks merge if branch protection enabled.

**Artifacts**:
- CI job logs
- GitHub status check (pass/fail)
- Comment on PR (if configured)

**Success Criteria**:
- All documents pass validation
- No stale documents detected
- CI completes in <30s
- Clear error messages if validation fails

**Error Scenarios**:

| Error | Cause | Resolution |
|-------|-------|-----------|
| "Stale document detected" | Doc not regenerated after source/prompt change | Developer runs `graft regenerate` locally |
| "Signature mismatch" | Manual edit to generated doc | Revert manual edit, update prompt instead |
| "Missing dependency" | Source file deleted | Remove or update prompt's source list |
| "Git history shallow" | `fetch-depth: 1` in checkout | Change to `fetch-depth: 0` |
| "Graft not installed" | Missing install step | Add `pip install graft` to workflow |

**Performance Characteristics**:
- Time: 10-30s for full validation (no LLM calls)
- Cost: $0 (uses GitHub Actions free tier)
- Runs: On every push to any branch
- Cached: Can cache pip install for faster runs

**Integration Points**:
- Triggered by **PR Preparation** push
- Blocks **Merge Enforcement**
- Complements **Preview Generation**
- Feeds into **Context Building** for reviewers

---

### Pattern: Preview Generation

**Actor**: CI System (GitHub Actions)

**Trigger**: PR opened or updated (optional workflow, expensive)

**Preconditions**:
- Repository has `.github/workflows/graft-preview.yml`
- LLM API credentials in GitHub Secrets
- Budget allocated for preview generations

**Steps**:

1. **CI workflow triggers on PR**
   
   `.github/workflows/graft-preview.yml`:
   ```yaml
   name: Generate Graft Preview
   
   on:
     pull_request:
       types: [opened, synchronize]
   
   jobs:
     preview:
       runs-on: ubuntu-latest
       # Only run on PRs with 'docs' label to control costs
       if: contains(github.event.pull_request.labels.*.name, 'docs')
       
       steps:
         - uses: actions/checkout@v4
           with:
             fetch-depth: 0
             ref: ${{ github.event.pull_request.head.sha }}
         
         - name: Install Graft
           run: pip install graft
         
         - name: Configure LLM credentials
           env:
             ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
           run: echo "ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY" >> $GITHUB_ENV
         
         - name: Identify changed documents
           id: changes
           run: |
             # Find docs that would be affected by this PR
             DOCS=$(graft status | grep "Stale" | awk '{print $1}')
             echo "docs=$DOCS" >> $GITHUB_OUTPUT
         
         - name: Generate previews
           id: generate
           run: |
             TOTAL_COST=0
             for doc in ${{ steps.changes.outputs.docs }}; do
               echo "Generating preview for $doc..."
               OUTPUT=$(graft regenerate "$doc" --dry-run)
               echo "$OUTPUT"
               
               # Extract cost (example, depends on actual output format)
               COST=$(echo "$OUTPUT" | grep "Cost:" | awk '{print $2}' | tr -d '$')
               TOTAL_COST=$(echo "$TOTAL_COST + $COST" | bc)
             done
             echo "total_cost=$TOTAL_COST" >> $GITHUB_OUTPUT
         
         - name: Post preview comment
           uses: actions/github-script@v7
           with:
             script: |
